#!/usr/bin/env python
#
# Copyright 2013 Greg Neagle
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""autopkg tool. Runs autopkg recipes and also handles other
related tasks"""

import glob
import sys
import os
import optparse
import FoundationPlist
import pprint
import shutil
import subprocess
import time
from urlparse import urlparse

from autopkglib import get_pref, get_all_prefs
from autopkglib import set_pref, PreferenceError
from autopkglib import AutoPackagerError, AutoPackager

_REPORT_PLIST = False


def log(msg, error=False):
    '''Message logger, prints to stdout/stderr and suppress stdout
    when --report-plist is used.'''
    if error:
        print >> sys.stderr, msg
    elif not _REPORT_PLIST and not error:
        print >> sys.stdout, msg


def log_err(msg):
    '''Message logger for errors.'''
    log(msg, error=True)


def recipe_has_step_processor(recipe, processor):
    '''Does the recipe object contain at least one step with the
    named Processor?'''
    if "Process" in recipe:
        processors = [step.get("Processor") for step in recipe["Process"]]
        if processor in processors:
            return True
    return False


def has_munkiimporter_step(recipe):
    '''Does the recipe have a MunkiImporter step?'''
    return recipe_has_step_processor(recipe, "MunkiImporter")


def has_check_phase(recipe):
    '''Does the recipe have a "check" phase?'''
    return recipe_has_step_processor(recipe, "EndOfCheckPhase")


def builds_a_package(recipe):
    '''Does this recipe build any packages?'''
    return recipe_has_step_processor(recipe, "PkgCreator")


def valid_plist_with_keys(filename, keys_to_verify):
    '''Attempts to read a plist file and ensures the keys in
    keys_to_verify exist. Returns False on any failure, True otherwise.'''
    try:
        # make sure we can read it
        recipe_plist = FoundationPlist.readPlist(filename)
    except FoundationPlist.FoundationPlistException, err:
        log_err("WARNING: plist error for %s: %s" % (filename, err))
        return False
    for key in keys_to_verify:
        if not key in recipe_plist:
            return False
    # if we get here, we found all the keys
    return True


def valid_recipe(filename):
    '''Returns True if filename contains a valid recipe,
    otherwise returns False'''
    return valid_plist_with_keys(filename, ["Input", "Process"])


def valid_override(filename):
    '''Returns True if filename contains a valid override,
    otherwise returns False'''
    return valid_plist_with_keys(filename, ["Input", "Recipe"])


def find_recipe(name, search_dirs, all_paths=False):
    '''Search search_dirs for a recipe, first by file/directory
    naming rules, then by the IDENTIFIER string. Returns the recipe
    path with the first match, or a list of paths if all_paths is
    True.'''
    # search by "Name", using file/directory hierarchy rules

    result = []
    for directory in search_dirs:
        normalized_dir = os.path.abspath(os.path.expanduser(directory))
        patterns  = [
            os.path.join(normalized_dir, "%s.recipe" % name),
            os.path.join(normalized_dir, "*/%s.recipe" % name)
        ]
        for pattern in patterns:
            matches = glob.glob(pattern)
            for match in matches:
                if valid_recipe(match):
                    result.append(match)

    if not result:
        # search by IDENTIFIER, trying to read every .recipe file
        for directory in search_dirs:
            for root, unused_dirs, files in os.walk(
                os.path.abspath(os.path.expanduser(directory))):
                for f in files:
                    if f.endswith(".recipe"):
                        fullpath = os.path.join(root, f)
                        try:
                            recipe_plist = FoundationPlist.readPlist(fullpath)
                        except FoundationPlist.FoundationPlistException:
                            continue
                        if "Input" in recipe_plist.keys():
                            if recipe_plist["Input"].get("IDENTIFIER") == name:
                                if valid_recipe(fullpath):
                                    result.append(fullpath)

    if all_paths:
        return result
    else:
        if result:
            return result[0]
    return None


def get_identifier(recipe):
    '''Given a loaded recipe dictionary from load_recipe(), return
    the identifier. This will return the identifier of the source
    recipe of an override is present via the 'OVERRIDE_PATH' key.'''
    identifier = None
    # pprint.pprint(recipe)
    if "OVERRIDE_PATH" in recipe.keys():
        override = FoundationPlist.readPlist(recipe["OVERRIDE_PATH"])
        identifier = override["Recipe"].get("identifier")
    
    # catch both cases of 1) no override, 2) no 'identifier' if override
    # was built before the time when make-override added identifiers
    if not identifier:
        identifier = recipe["Input"].get("IDENTIFIER")
    return identifier


def load_recipe(name, override_dirs, recipe_dirs):
    '''Loads a recipe. If the name contains a path seperator or a file
    extension, we assume the name is a pathname and attempt to load the
    override or recipe from the pathname.
    Otherwise, we treat name as a simple name and search first the override
    directories, then the recipe directories for a matching recipe.
    If we find one, we load it and return the plist object (which should be
    functionally equivelent to a dictionary). If an override file is used,
    it prefers finding the original recipe by identifier rather than name,
    so that if recipe names shift with updated recipe repos, the override
    still applies to the recipe from which it was derived.'''

    def get_identifier_from_override(override):
        '''Return the identifier from an override, falling back with a
        warning to just the 'name' of the recipe.'''
        identifier = override['Recipe'].get("identifier")
        if identifier:
            name = identifier
        else:
            name = override['Recipe'].get("name")
            log_err("WARNING: Override contains no identifier. Will fall "
                    "back to matching it by name using search rules. It's "
                    "recommended to give the original recipe identifier "
                    "in the override's 'Recipes' dict to ensure the same "
                    "recipe is always used for this override.")
        return name

    override = None
    if os.path.isfile(name):
        # name is path to a specific recipe or override file
        # ignore override and recipe directories
        # and attempt to open the file specified by name
        if valid_override(name):
            override = FoundationPlist.readPlist(name)
            override["OVERRIDE_PATH"] = os.path.abspath(name)
            name = get_identifier_from_override(override)
            # fall through to get the actual recipe
        elif valid_recipe(name):
            recipe = FoundationPlist.readPlist(name)
            recipe["RECIPE_PATH"] = os.path.abspath(name)
            return recipe

    if not override:
        if name.endswith(".recipe"):
            name = os.path.splitext(name)[0]
        # first look in override_dirs for name.recipe
        for directory in override_dirs:
            normalized_dir = os.path.abspath(os.path.expanduser(directory))
            search_names  = [
                os.path.join(normalized_dir, "%s.recipe" % name),
            ]
            for pathname in search_names:
                if os.path.exists(pathname) and valid_override(pathname):
                    override = FoundationPlist.readPlist(pathname)
                    name = get_identifier_from_override(override)
                    override["OVERRIDE_PATH"] = os.path.abspath(pathname)
                    break

    # now get the actual recipe
    if name:
        recipe_path = find_recipe(name, recipe_dirs)
        if recipe_path:
            try:
                recipe = FoundationPlist.readPlist(recipe_path)
            except FoundationPlist.FoundationPlistException:
                return None
            # apply overrides
            if override:
                recipe["OVERRIDE_PATH"] = override["OVERRIDE_PATH"]
                for key in override["Input"].keys():
                    recipe["Input"][key] = override["Input"][key]
            # store the recipe path for use by overrides, etc
            recipe["RECIPE_PATH"] = os.path.abspath(recipe_path)
            return recipe
    return None


def get_recipe_info(recipe_name, override_dirs, recipe_dirs):
    '''Loads a recipe, then prints some information about it. Override aware.'''
    recipe = load_recipe(recipe_name, override_dirs, recipe_dirs)
    if recipe:
        log("Description:         %s" %
            "\n                     ".join(
                    recipe.get("Description", "").splitlines()))
        log("Munki import recipe: %s" % has_munkiimporter_step(recipe))
        log("Has check phase:     %s" % has_check_phase(recipe))
        log("Builds package:      %s" % builds_a_package(recipe))
        log("Recipe file path:    %s" % recipe["RECIPE_PATH"])
        if recipe.get("OVERRIDE_PATH"):
            log("Override path:       %s" % recipe["OVERRIDE_PATH"])
        log("Input values: ")
        output = pprint.pformat(recipe.get("Input", {}), indent=4)
        log(" " + output[1:-1])
        return True
    else:
        return False


def git_cmd():
    """Returns a path to a git binary, priority in the order below.
    Returns None if none found.
    1. app pref 'GIT_PATH'
    2. a 'git' binary that can be found in the PATH environment variable
    3. '/usr/bin/git'
    """

    def is_executable(exe_path):
        '''Is exe_path executable?'''
        return os.path.exists(exe_path) and os.access(exe_path, os.X_OK)

    git_path_pref = get_pref("GIT_PATH")
    if git_path_pref:
        if is_executable(git_path_pref):
            # take a GIT_PATH pref
            return git_path_pref
        else:
            log_err("WARNING: Git path given in the 'GIT_PATH' preference:'%s' "
                    "either doesn't exist or is not executable! Falling back "
                    "to one set in PATH, or /usr/bin/git." % git_path_pref)
    for path_env in os.environ["PATH"].split(":"):
        gitbin = os.path.join(path_env, "git")
        if is_executable(gitbin):
            # take the first 'git' in PATH that we find
            return gitbin
    if is_executable("/usr/bin/git"):
        # fall back to /usr/bin/git
        return "/usr/bin/git"
    return None


class GitError(Exception):
    '''Exception to throw if git fails'''
    pass


def run_git(git_options_and_arguments, git_directory=None):
    '''Run a git command and return its output if successful;
       raise GitError if unsuccessful.'''
    gitcmd = git_cmd()
    if not gitcmd:
        raise GitError("ERROR: git is not installed!")
    cmd = [gitcmd]
    cmd.extend(git_options_and_arguments)
    try:
        proc = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            cwd=git_directory)
        (cmd_out, cmd_err) = proc.communicate()
    except OSError as err:
        raise GitError("ERROR: git execution failed with error code %d: %s"
                       % (err.errno, err.strerror))
    if proc.returncode != 0:
        raise GitError("ERROR: %s" % cmd_err)
    else:
        return cmd_out


def get_recipe_repo(git_path):
    """git clone git_path to local disk and return local path"""

    # figure out a local directory name to clone to
    parts = urlparse(git_path)
    domain_and_port = parts.netloc
    # discard port if any
    domain = domain_and_port.split(':')[0]
    reverse_domain = '.'.join(reversed(domain.split('.')))
    # discard file extension if any
    url_path = os.path.splitext(parts.path)[0]
    dest_name = reverse_domain + url_path.replace('/', '.')
    recipe_repo_dir = (get_pref("RECIPE_REPO_DIR") or
                       os.path.expanduser("~/Library/AutoPkg/RecipeRepos"))
    dest_dir = os.path.join(recipe_repo_dir, dest_name)
    dest_dir = os.path.abspath(dest_dir)
    gitcmd = git_cmd()
    if not gitcmd:
        log_err("No git binary could be found!")
        return None

    if os.path.exists(dest_dir):
        # probably should attempt a git pull
        # check to see if this is really a git repo first
        if not os.path.isdir(os.path.join(dest_dir, '.git')):
            log_err("%s exists and is not a git repo!" % dest_dir)
            return None
        log("Attempting git pull...")
        try:
            log(run_git(['pull'], git_directory=dest_dir))
            return dest_dir
        except GitError, err:
            log_err(err)
            return None
    else:
        log("Attempting git clone...")
        try:
            log(run_git(['clone', git_path, dest_dir]))
            return dest_dir
        except GitError, err:
            log_err(err)
            return None
    return None


def print_new_imports(new_imports):
    '''Print new Munki imports in a table format'''
    log("    %-24s %-16s %-32s %s" % (
        "Name", "Version", "Catalogs", "Pkginfo Path"))
    log("    %-24s %-16s %-32s %s" % (
        "----", "-------", "--------", "------------"))
    for item in new_imports:
        log("    %-24s %-16s %-32s %s" % (
            item["name"], item["version"], ", ".join(item["catalogs"]),
            item["pkginfo_path"].partition("pkgsinfo/")[2]))


def print_tool_info(options):
    """Eventually will print some information about the tool
    and environment. For now, just print the current prefs"""
    print "Current preferences:"
    pprint.pprint(get_all_prefs())


def get_repo_info(path_or_url):
    '''Given a path or URL, find a locally installed repo and return
    infomation in a dictionary about it'''
    repo_info = {}
    recipe_repos = dict(get_pref("RECIPE_REPOS") or {})

    parsed = urlparse(path_or_url)
    if parsed.netloc:
        # it's a URL, look it up and find the associated path
        repo_url = path_or_url
        for repo_path in recipe_repos.keys():
            test_url = recipe_repos[repo_path].get("URL")
            if repo_url == test_url:
                # found it; copy the dict info
                repo_info['path'] = repo_path
                repo_info.update(recipe_repos[repo_path])
                # get out now!
                return repo_info
    else:
        repo_path = os.path.abspath(os.path.expanduser(path_or_url))
        if repo_path in recipe_repos:
            repo_info['path'] = repo_path
            repo_info.update(recipe_repos[repo_path])
    return repo_info


def save_pref_or_warn(key, value):
    '''Saves a key and value to preferences, warning if there is an issue'''
    try:
        set_pref(key, value)
    except PreferenceError, err:
        log_err("WARNING: %s" % err)


def get_search_dirs():
    '''Return search dirs from preferences or default list'''
    default = [
        ".",
        "~/Library/AutoPkg/Recipes",
        "/Library/AutoPkg/Recipes"
        ]

    dirs = get_pref("RECIPE_SEARCH_DIRS")
    if isinstance(dirs, basestring):
        # convert a string to a list
        dirs = [dirs]
    return dirs or default


def get_override_dirs():
    '''Return override dirs from preferences or default list'''
    default = [
        "~/Library/AutoPkg/RecipeOverrides"
        ]

    dirs = get_pref("RECIPE_OVERRIDE_DIRS")
    if isinstance(dirs, basestring):
        # convert a string to a list
        dirs = [dirs]
    return dirs or default


def add_search_and_override_dir_options(p):
    '''Several subcommands use these same options'''
    p.add_option("-d", "--search-dir", metavar="DIRECTORY", dest="search_dirs",
                 action="append", default=[],
                 help=("Directory to search for recipes. Can be specified "
                                    "multiple times."))
    p.add_option("--override-dir", metavar="DIRECTORY", dest="override_dirs",
                 action="append", default=[],
                 help=("Directory to search for recipe overrides. Can be "
                       "specified multiple times."))


########################
# subcommand functions #
########################

def repo_add(argv):
    '''Add/update one or more repos of recipes'''
    verb = argv[1]
    p = optparse.OptionParser()
    p.set_usage("Usage: %s %s recipe_repo_url\n"
        "Download one or more new recipe repos and add it to the search path."
        % ("%prog", verb))

    # Parse arguments
    options, arguments = p.parse_args(argv[2:])
    if len(arguments) < 1:
        log_err("Need at least one recipe repo URL!")
        return -1

    recipe_search_dirs = list(get_search_dirs())
    recipe_repos = dict(get_pref("RECIPE_REPOS") or {})
    for repo_url in arguments:
        new_recipe_repo_dir = get_recipe_repo(repo_url)
        if new_recipe_repo_dir:
            if not new_recipe_repo_dir in recipe_search_dirs:
                log("Adding %s to RECIPE_SEARCH_DIRS..." % new_recipe_repo_dir)
                recipe_search_dirs.append(new_recipe_repo_dir)
            # add info about this repo to our prefs
            recipe_repos[new_recipe_repo_dir] = {"URL": repo_url}

    # save our updated RECIPE_REPOS and RECIPE_SEARCH_DIRS
    save_pref_or_warn("RECIPE_REPOS", recipe_repos)
    save_pref_or_warn("RECIPE_SEARCH_DIRS", recipe_search_dirs)

    log("Recipe search path is: %s"
                            % get_pref("RECIPE_SEARCH_DIRS"))
    warn_dupe_identifiers(recipe_search_dirs)


def repo_delete(argv):
    '''Delete a recipe repo'''
    main_command_name = os.path.basename(argv[0])
    verb = argv[1]
    p = optparse.OptionParser()
    p.set_usage("Usage: %s %s recipe_repo_path_or_url [...]\n"
        "Delete one or more recipe repo and remove it from the search path."
        % ("%prog", verb))

    # Parse arguments
    options, arguments = p.parse_args(argv[2:])
    if len(arguments) < 1:
        log_err("Need at least one recipe repo path or URL!")
        return -1

    recipe_repos = dict(get_pref("RECIPE_REPOS") or {})
    recipe_search_dirs = list(get_search_dirs())

    for path_or_url in arguments:
        repo_path = get_repo_info(path_or_url).get('path')
        if not repo_path:
            log_err("ERROR: Can't find an installed repo for %s" % path_or_url)
            continue

        # first, remove from RECIPE_SEARCH_DIRS
        if repo_path in recipe_search_dirs:
            recipe_search_dirs.remove(repo_path)
        # now remove the repo files
        try:
            shutil.rmtree(repo_path)
        except (OSError, IOError), err:
            log_err("ERROR: Could not remove %s: %s" % (repo_path, err))
        else:
            # last, remove from RECIPE_REPOS
            del recipe_repos[repo_path]

    # save our updated RECIPE_REPOS and RECIPE_SEARCH_DIRS
    save_pref_or_warn("RECIPE_REPOS", recipe_repos)
    save_pref_or_warn("RECIPE_SEARCH_DIRS", recipe_search_dirs)


def repo_list(argv):
    '''List recipe repos'''
    verb = argv[1]
    p = optparse.OptionParser()
    p.set_usage("Usage: %s %s\n"
        "List all installed recipe repos."
        % ("%prog", verb))

    # Parse arguments
    options, arguments = p.parse_args(argv[2:])

    recipe_repos = dict(get_pref("RECIPE_REPOS") or {})
    if recipe_repos:
        for key in sorted(recipe_repos.keys()):
            print "%s (%s)" % (key, recipe_repos[key]['URL'])
        print
    else:
        print "No recipe repos."


def repo_update(argv):
    '''Update one or more recipe repos'''
    main_command_name = os.path.basename(argv[0])
    verb = argv[1]
    p = optparse.OptionParser()
    p.set_usage("Usage: %s %s recipe_repo_path_or_url [...]\n"
        "Delete one or more recipe repo and remove it from the search path.\n"
        "You may also use 'all' to update all installed recipe repos.It"
        % ("%prog", verb))

    # Parse arguments
    options, arguments = p.parse_args(argv[2:])
    if len(arguments) < 1:
        log_err("Need at least one recipe repo path or URL!")
        return -1

    if 'all' in arguments:
        # just get all repos
        recipe_repos = dict(get_pref("RECIPE_REPOS") or {})
        repo_dirs = [key for key in recipe_repos.keys()]
    else:
        repo_dirs = []
        for path_or_url in arguments:
            repo_path = get_repo_info(path_or_url).get('path')
            if not repo_path:
                log_err("ERROR: Can't find an installed repo for %s"
                         % path_or_url)
            else:
                repo_dirs.append(repo_path)

    for repo_dir in repo_dirs:
        log("Attempting git pull for %s..." % repo_dir)
        try:
            log(run_git(['pull'], git_directory=repo_dir))
        except GitError, err:
            log_err(err)

    warn_dupe_identifiers(repo_dirs)


def display_help(argv, subcommands):
    '''Display top-level help'''
    main_command_name = os.path.basename(argv[0])
    print ("Usage: %s <verb> <options>, where <verb> is one of the following:"
           % main_command_name)
    print
    # find length of longest subcommand
    max_key_len = max([len(key) for key in subcommands.keys()])
    for key in sorted(subcommands.keys()):
        # pad name of subcommand to make pretty columns
        subcommand = key + (" " * (max_key_len - len(key)))
        print "    %s  (%s)" % (subcommand, subcommands[key]['help'])
    print
    print "%s <verb> --help for more help for that verb" % main_command_name


def get_info(argv):
    '''Display info about configuration or a recipe'''
    verb = argv[1]
    p = optparse.OptionParser()
    p.set_usage("Usage: %s %s [options] [recipe]" % ("%prog", verb))

    # Parse arguments
    add_search_and_override_dir_options(p)
    options, arguments = p.parse_args(argv[2:])

    override_dirs = options.override_dirs or get_override_dirs()
    search_dirs = options.search_dirs or get_search_dirs()

    if len(arguments) == 0:
        # return configuration info
        print_tool_info(options)
        return 0
    elif len(arguments) == 1:
        if get_recipe_info(arguments[0], override_dirs, search_dirs):
            return 0
        else:
            log_err("Can't find recipe %s" % arguments[0])
            return -1
    else:
        log_err("Too many recipes!")
        return -1


def warn_dupe_identifiers(search_dirs):
    '''Given a list of recipe search directories, print a warning
    for any recipes discovered that have multiple identical
    identifiers.'''

    ids_paths = {}
    # - we don't need overrides for this so we pass an empty list to override_dirs
    recipe_identifiers = get_recipe_list([], search_dirs, identifiers=True)
    for r in recipe_identifiers:
        paths = find_recipe(r, search_dirs, all_paths=True)
        if len(paths) > 1:
            if r not in ids_paths.keys():
                ids_paths[r] = set()
            for path in paths:
                ids_paths[r].add(path)

    for identifier, paths in ids_paths.items():
        log_err("WARNING: Recipe identifier '%s' found in multiple recipes "
                "in search paths:" % identifier)
        for path in paths:
            log_err("  - %s" % path)


def get_recipe_list(override_dirs, search_dirs, identifiers=False):
    '''Returns a list of recipe names, optionally by identifiers
    instead of names.'''
    recipes = set()

    # find all valid overrides first
    for directory in override_dirs:
        normalized_dir = os.path.abspath(os.path.expanduser(directory))
        for filename in os.listdir(normalized_dir):
            if filename.endswith(".recipe"):
                pathname = os.path.join(normalized_dir, filename)
                if valid_override(pathname):
                    override = FoundationPlist.readPlist(pathname)
                    name = override['Recipe'].get("name")
                    # find and validate recipe that will be overridden
                    recipe_path = find_recipe(name, search_dirs)
                    if recipe_path and valid_recipe(recipe_path):
                        # override points to a valid recipe
                        recipes.add(os.path.splitext(filename)[0])

    for directory in search_dirs:
        normalized_dir = os.path.abspath(os.path.expanduser(directory))
        # find all top-level recipes
        matches = glob.glob(os.path.join(normalized_dir, "*.recipe"))
        for match in matches:
            if valid_recipe(match):
                basename = os.path.basename(match)
                recipes.add(os.path.splitext(basename)[0])

        # look for recipes one level down
        matches = glob.glob(os.path.join(normalized_dir, "*/*.recipe"))
        for match in matches:
            if valid_recipe(match):
                recipe_name = os.path.basename(match)
                # get rid of file extension
                recipe_name = os.path.splitext(recipe_name)[0]
                recipes.add(recipe_name)

    recipe_list = sorted(list(recipes))

    if identifiers:
        id_list = []
        for r in recipe_list:
            # print r
            recipe_data = load_recipe(r, override_dirs, search_dirs)
            identifier = get_identifier(recipe_data)
            id_list.append(identifier)
        recipe_list = sorted(id_list)

    return recipe_list

def list_recipes(argv):
    '''List all available recipes'''
    verb = argv[1]
    p = optparse.OptionParser()
    p.set_usage("Usage: %s %s [options]\n"
        "List all the recipes this tool can find automatically."
        % ("%prog", verb))
    p.add_option("--identifiers", action="store_true",
        help="List recipe identifiers instead of names.")

    # Parse arguments
    add_search_and_override_dir_options(p)
    options, arguments = p.parse_args(argv[1:])

    override_dirs = options.override_dirs or get_override_dirs()
    search_dirs = options.search_dirs or get_search_dirs()

    recipe_list = get_recipe_list(override_dirs, search_dirs, options.identifiers)
    print "\n".join(recipe_list)
    warn_dupe_identifiers(search_dirs)


def make_override(argv):
    '''Make a recipe override skeleton.'''
    verb = argv[1]
    p = optparse.OptionParser()

    p.set_usage("Usage: %s %s [options] [recipe]\n"
        "Create a skeleton override file for a recipe. It will "
        "be stored in the first default override directory "
        "or that given by '--override-dir'" % ("%prog", verb))

    # Parse arguments
    add_search_and_override_dir_options(p)
    p.add_option("-n", "--name", metavar="FILENAME",
                 help="Name for override file.")
    options, arguments = p.parse_args(argv[2:])

    override_dirs = options.override_dirs or get_override_dirs()
    search_dirs = options.search_dirs or get_search_dirs()

    if len(arguments) != 1:
        log_err("Need exactly one recipe to override!")
        return -1

    recipe_name = arguments[0]
    if os.path.isfile(recipe_name):
        log_err("%s doesn't work with absolute recipe paths, "
                "as it may not be able to correctly determine the value "
                "for 'name' that would be searched in recipe directories."
                % verb)
        return -1

    recipe = load_recipe(recipe_name,
                         override_dirs=[],
                         recipe_dirs=search_dirs)
    if not recipe:
        log_err("No valid recipe found for %s" % recipe_name)
        log_err("Dir(s) searched: %s" % ":".join(search_dirs))
        return 1
    override_plist = dict({"Recipe":
                            {"name": recipe_name,
                             "identifier": recipe["Input"]["IDENTIFIER"]}
                           }
                          )
    override_plist["Input"] = recipe["Input"]
    
    override_name = (options.name 
        or os.path.splitext(os.path.basename(recipe["RECIPE_PATH"]))[0])
    override_out_file = os.path.expanduser(
        os.path.join(override_dirs[0], "%s.recipe" % override_name))
    if os.path.exists(override_out_file):
        log_err("An override plist already exists at %s, "
                "will not overwrite it." % override_out_file)
        return -1
    else:
        FoundationPlist.writePlist(override_plist, override_out_file)
        log("Override file saved to %s." % override_out_file)
        return 0


def run_recipes(argv):
    """Run one or more recipes"""
    verb = argv[1]
    p = optparse.OptionParser()
    p.set_usage("Usage: %s %s [options] [recipe ...]\n"
        "Run one or more recipes." % ("%prog", verb))

    # Parse arguments.
    p.add_option("-c", "--check", action="store_true",
                 help="Only check for new/changed downloads.")
    p.add_option("-k", "--key", action="append", dest="variables", default=[],
                 metavar="KEY=VALUE",
                 help=("Provide key/value pairs for recipe input. "
                       "Caution: values specified here will be applied "
                       "to all recipes."))
    p.add_option("-l", "--recipe-list", metavar="TEXT_FILE",
                 help="Path to a text file with a list of recipes to run.")
    p.add_option("-p", "--pkg", metavar="PKG_OR_DMG",
                 help=("Path to a pkg or dmg to provide to a recipe. "
                       "Downloading will be skipped."))
    p.add_option("--report-plist", action="store_true", default=False,
                 help="Output run report data in plist format to stdout. "
                      "Additional messages may still be printed to stderr.")
    p.add_option("-v", "--verbose", action="count", default=0,
                 help="Verbose output.")
    add_search_and_override_dir_options(p)
    options, arguments = p.parse_args(argv[2:])

    override_dirs = options.override_dirs or get_override_dirs()
    search_dirs = options.search_dirs or get_search_dirs()

    # initialize some variables
    new_downloads = []
    new_packages = []
    new_imports = []
    failures = []

    # Add variables from commandline.
    cli_values = {}
    for arg in options.variables:
        (key, sep, value) = arg.partition("=")
        if sep != "=":
            log_err("Invalid variable [key=value]: %s" % arg)
            log_err(p.get_usage())
            return 1
        cli_values[key] = value

    if options.pkg:
        cli_values["PKG"] = options.pkg

    # so that log() can make use of it
    global _REPORT_PLIST
    _REPORT_PLIST = options.report_plist
    if _REPORT_PLIST:
        options.verbose = 0

    recipe_paths = []
    recipe_paths.extend(arguments)
    if options.recipe_list:
        with open(options.recipe_list, "r") as fd:
            data = fd.read()
        recipes = [line for line in data.splitlines()
                   if line and not line.startswith("#")]
        recipe_paths.extend(recipes)

    if not recipe_paths:
        log_err(p.get_usage())
        return 1

    if len(recipe_paths) > 1 and options.pkg:
        log_err("-p/--pkg option can't be used with multiple recipes!")
        return 1

    cache_dir = get_pref("CACHE_DIR") or os.path.expanduser(
                "~/Library/AutoPkg/Cache")
    current_run_results_plist = os.path.join(cache_dir, "autopkg_results.plist")

    run_results = []
    try:
        FoundationPlist.writePlist(run_results, current_run_results_plist)
    except IOError as err:
        log_err(
            "Can't write results to %s: %s"
            % (current_run_results_plist, err.strerror))

    for recipe_path in recipe_paths:
        recipe = load_recipe(recipe_path, override_dirs, search_dirs)
        if not recipe:
            log_err("No valid recipe found for %s" % recipe_path)
            continue

        if options.check:
            # remove steps from the end of the recipe Process until we find a
            # EndOfCheckPhase step
            while len(recipe["Process"]) >= 1 and \
                    recipe["Process"][-1]["Processor"] != "EndOfCheckPhase":
                del recipe["Process"][-1]
            if len(recipe["Process"]) == 0:
                log_err("Recipe at %s is missing EndOfCheckPhase Processor, "
                        "not possible to perform check." % recipe_path)
                continue

        log("Processing %s..." % recipe_path)
        # Obtain prefs from the defaults domain
        prefs = get_all_prefs()
        # Add RECIPE_PATH and RECIPE_DIR variables for use by processors
        prefs["RECIPE_PATH"] = os.path.abspath(recipe["RECIPE_PATH"])
        prefs["RECIPE_DIR"] = os.path.dirname(prefs["RECIPE_PATH"])

        # Add our verbosity level
        prefs["verbose"] = options.verbose

        autopackager = AutoPackager(options, prefs)

        try:
            autopackager.process_cli_overrides(recipe, cli_values)
            autopackager.verify(recipe)
            autopackager.process(recipe)
        except AutoPackagerError as err:
            failure = {}
            log_err("Failed.")
            failure["recipe"] = recipe_path
            failure["message"] = str(err)
            failures.append(failure)
            autopackager.results.append({'RecipeError': str(err).rstrip()})

        run_results.append(autopackager.results)
        try:
            FoundationPlist.writePlist(run_results, current_run_results_plist)
        except IOError as err:
            log_err(
                "Can't write results to %s: %s"
                % (current_run_results_plist, err.strerror))

        # build a pathname for a receipt
        recipe_basename = os.path.splitext(os.path.basename(recipe_path))[0]
        # TO-DO: if recipe processing fails too early, 
        # autopackager.env["RECIPE_CACHE_DIR"] is not defined and we can't
        # write a recipt. We should handle this better.
        # for now, just write the receipt to /tmp/receipts
        receipt_dir = os.path.join(
            autopackager.env.get("RECIPE_CACHE_DIR", "/tmp"), "receipts")
        timestamp = time.strftime("%Y%m%d-%H%M%S")
        receipt_name = "%s-receipt-%s.plist" % (recipe_basename, timestamp)
        
        if not os.path.exists(receipt_dir):
            try:
                os.makedirs(receipt_dir)
            except OSError, err:
                log_err("Can't create %s: %s" % (receipt_dir, err.strerror))
        
        if os.path.exists(receipt_dir):
            receipt_path = os.path.join(receipt_dir, receipt_name)
            try:
                FoundationPlist.writePlist(autopackager.results, receipt_path)
                if options.verbose:
                    log("Receipt written to %s" % receipt_path)
            except IOError as err:
                log_err("Can't write receipt to %s: %s" 
                        % (receipt_path, err.strerror))

        # look through results for interesting info
        # and record for later summary and use
        for item in autopackager.results:
            if item.get("Output"):
                # look for changed downloads
                if item["Output"].get("download_changed"):
                    new_downloads.append(item["Output"].get("pathname"))
        
                # look for packages
                if item["Output"].get("pkg_path"):
                    new_packages.append(item["Output"].get("pkg_path"))
        
                # look for items imported into munki repo
                if item["Output"].get("pkginfo_repo_path"):
                    imported_item = {}
                    imported_item["name"] = item["Output"]["munki_info"]["name"]
                    imported_item["version"] = item[
                                            "Output"]["munki_info"]["version"]
                    imported_item["catalogs"] = item[
                                            "Output"]["munki_info"]["catalogs"]
                    imported_item["pkginfo_path"] = item["Output"].get(
                                                            "pkginfo_repo_path")
                    imported_item["pkg_path"] = item["Output"].get(
                                                                "pkg_repo_path")
                    new_imports.append(imported_item)

    # done running recipes, print a summary
    if failures:
        log("\nThe following recipes failed:")
        for item in failures:
            log("    %s" % item["recipe"])
            log("        %s" % item["message"])

    if new_downloads:
        log("\nThe following new items were downloaded:")
        for item in new_downloads:
            log("    %s" % item)

    if new_packages:
        log("\nThe following packages were built:")
        for item in new_packages:
            log("    %s" % item)

    if new_imports:
        log("\nThe following new items were imported:")
        print_new_imports(new_imports)
        log("\n")

    if not new_downloads and not new_packages and not new_imports:
        log("\nNothing downloaded, packaged or imported.")

    if _REPORT_PLIST:
        results_report = {}
        for event_type in ["failures", "new_downloads", "new_imports"]:
            results_report[event_type] = locals()[event_type]
        print FoundationPlist.writePlistToString(results_report)


def main(argv):
    """Main routine"""
    # define our subcommands ('verbs')
    subcommands = {
        "help": {
            "function": display_help,
            "help": "Display this help"},
        "info": {
            "function": get_info,
            "help": "Get info about configuration or a recipe"},
        "list-recipes": {
            "function": list_recipes,
            "help": "List available recipes"},
        "make-override": {
            "function": make_override,
            "help": "Make a recipe override"},
        "repo-add": {
            "function": repo_add,
            "help": "Add one or more recipe repo from a URL."},
        "repo-delete": {
            "function": repo_delete,
            "help": "Delete a recipe repo."},
        "repo-list": {
            "function": repo_list,
            "help": "List installed recipe repos."},
        "repo-update": {
            "function": repo_update,
            "help": "Update one or more recipe repos."},
        "run": {
            "function": run_recipes,
            "help": "Run one or more recipes"}
    }

    try:
        verb = argv[1]
    except IndexError:
        verb = 'help'
    if verb.startswith("-"):
        # option instead of a verb
        verb = 'help'
    if verb == 'help' or not verb in subcommands.keys():
        display_help(argv, subcommands)
    else:
        # call the function and pass it the argument list
        # we leave the verb in the list in case one function can handle
        # multiple verbs
        exit(subcommands[verb]['function'](argv))

    exit()


if __name__ == "__main__":
    sys.exit(main(sys.argv))

